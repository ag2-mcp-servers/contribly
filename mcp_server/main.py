# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:23:30+00:00



import argparse
import json
import os
from datetime import date, datetime
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, OAuth2PasswordBearer
from fastapi import Query

from models import (
    ArtifactFormats,
    Assignment,
    AssignmentsGetResponse,
    AssignmentSubmission,
    Authority,
    ChangeLogGetResponse,
    Contribution,
    ContributionRefinementsGetResponse,
    ContributionRefinementTypesGetResponse,
    ContributionsGetResponse,
    ContributionsIdLikesGetResponse,
    CredentialsGetResponse,
    ErrorResponse,
    EventTypesGetResponse,
    Export,
    ExportSummary,
    Flag,
    Form,
    FormResponse,
    FormResponsesGetResponse,
    FormResponseSubmission,
    FormsGetResponse,
    FormSubmission,
    LinkedProfile,
    Media,
    ModerationHistoryItemSubmission,
    NotificationPreview,
    ScopesGetResponse,
    SubscriptionsGetResponse,
    SubscriptionSubmission,
    SubscriptionTypesGetResponse,
    Tag,
    TagSet,
    TagsetsGetResponse,
    TagSetSubmission,
    TagsGetResponse,
    TagSubmission,
    User,
    UsersGetResponse,
)

app = MCPProxy(
    contact={'x-twitter': 'contribly'},
    title='Contribly',
    version='1.0.0',
    servers=[{'url': 'https://api.contribly.com/1'}],
)


@app.get(
    '/artifact-formats',
    description=""" List the available artifact formats """,
    tags=['artifact_format_management'],
)
def get_artifact_formats():
    """
    Artifact formats
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/assignments', tags=['assignment_management'])
def get_assignments(
    owned_by: Optional[str] = Query(None, alias='ownedBy'),
    page: Optional[int] = None,
    page_size: Optional[int] = Query(None, alias='pageSize'),
    q: Optional[str] = None,
    url_words: Optional[str] = Query(None, alias='urlWords'),
    open: Optional[bool] = None,
    always_open: Optional[bool] = Query(None, alias='alwaysOpen'),
    tag: Optional[str] = None,
    name: Optional[str] = None,
):
    """
    List assignments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/assignments', tags=['assignment_management'])
def post_assignments(body: AssignmentSubmission):
    """
    Create a new assignment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/assignments/{id}', tags=['assignment_management', 'contribution_management']
)
def delete_assignments__id(id: str):
    """
    Delete this assignment and all of it's contributions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/assignments/{id}', tags=['assignment_management'])
def get_assignments__id(id: str):
    """
    Get a single assigment by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/change-log',
    description=""" The Contribly change log. """,
    tags=['change_log_retrieval'],
)
def get_change_log():
    """
    Recent changes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/contribution-refinement-types', tags=['contribution_management'])
def get_contribution_refinement_types():
    """
    List valid contribution refinement types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contribution-refinements',
    description=""" Given a contribution list query determine the available filter options. Can be used to generate the UI to refinement a filter. """,
    tags=['contribution_management'],
)
def get_contribution_refinements(
    assignment: Optional[str] = None,
    country: Optional[str] = None,
    created_before: Optional[datetime] = Query(None, alias='createdBefore'),
    created_after: Optional[datetime] = Query(None, alias='createdAfter'),
    geohash: Optional[str] = None,
    has_location: Optional[bool] = Query(None, alias='hasLocation'),
    lat_long: Optional[str] = Query(None, alias='latLong'),
    radius: Optional[float] = None,
    media_type: Optional[str] = Query(None, alias='mediaType'),
    owned_by: Optional[str] = Query(None, alias='ownedBy'),
    q: Optional[str] = None,
    url_words: Optional[str] = Query(None, alias='urlWords'),
    user: Optional[str] = None,
    refinements: Optional[str] = None,
    refinement_size: Optional[float] = Query(None, alias='refinementSize'),
):
    """
    List contribution refinement options
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contributions',
    description=""" Retrieve contributions. """,
    tags=['contribution_management'],
)
def get_contributions(
    assignment: Optional[str] = None,
    country: Optional[str] = None,
    created_before: Optional[datetime] = Query(None, alias='createdBefore'),
    created_after: Optional[datetime] = Query(None, alias='createdAfter'),
    created_day: Optional[date] = Query(None, alias='createdDay'),
    created_month: Optional[str] = Query(None, alias='createdMonth'),
    geohash: Optional[str] = None,
    has_location: Optional[bool] = Query(None, alias='hasLocation'),
    lat_long: Optional[str] = Query(None, alias='latLong'),
    radius: Optional[float] = None,
    media_type: Optional[str] = Query(None, alias='mediaType'),
    owned_by: Optional[str] = Query(None, alias='ownedBy'),
    q: Optional[str] = None,
    url_words: Optional[str] = Query(None, alias='urlWords'),
    user: Optional[str] = None,
    ids: Optional[str] = None,
    format: Optional[str] = None,
):
    """
    List contributions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/contributions',
    tags=['contribution_management'],
    security=[
        OAuth2PasswordBearer(
            name="None",
            token_url="https://api.contribly.com/1/https://api.contriby.com/1/token",
        ),
    ],
)
def post_contributions(body: Contribution):
    """
    Create a new contribution
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/contributions/{id}', tags=['contribution_management', 'assignment_management']
)
def delete_contributions__id(id: str):
    """
    Delete this contribution
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/contributions/{id}', tags=['contribution_management'])
def get_contributions__id(id: str):
    """
    Get a single contribution by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/contributions/{id}/flag',
    description=""" Allows end users to bring potential issues with publicly visible content to the attention of moderators. """,
    tags=['contribution_management'],
)
def post_contributions__id_flag(id: str, body: Flag = ...):
    """
    Raise a flag against this contribution
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/contributions/{id}/like', tags=['contribution_management'])
def post_contributions__id_like(id: str):
    """
    Allows a user to mark a contribution as liked
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contributions/{id}/likes',
    description=""" Returns a list of user ids of users who have liked this conribution """,
    tags=['contribution_management', 'user_profile_management'],
)
def get_contributions__id_likes(id: str):
    """
    List users who have liked this contributions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/contributions/{id}/moderate',
    description=""" Allows the contribution to approved of rejected. """,
    tags=['contribution_management'],
)
def post_contributions__id_moderate(
    id: str, body: ModerationHistoryItemSubmission = ...
):
    """
    Perform a moderation action on this contribution
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/credentials', tags=['user_authentication_credentials', 'user_profile_management']
)
def get_credentials():
    """
    List the credentials associated with the authenticated user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/event-types',
    description=""" List available notification event types """,
    tags=['change_log_retrieval'],
)
def get_event_types():
    """
    Event types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/export',
    description=""" Begin an export job. Returns a export job which can be polled to follow the progress of an export. """,
    tags=['contribution_management', 'data_export_management'],
)
def post_export(
    assignment: Optional[str] = None,
    country: Optional[str] = None,
    created_before: Optional[datetime] = Query(None, alias='createdBefore'),
    created_after: Optional[datetime] = Query(None, alias='createdAfter'),
    geohash: Optional[str] = None,
    has_location: Optional[bool] = Query(None, alias='hasLocation'),
    lat_long: Optional[str] = Query(None, alias='latLong'),
    radius: Optional[float] = None,
    media_type: Optional[str] = Query(None, alias='mediaType'),
    owned_by: Optional[str] = Query(None, alias='ownedBy'),
    q: Optional[str] = None,
    url_words: Optional[str] = Query(None, alias='urlWords'),
    user: Optional[str] = None,
    tagged: Optional[bool] = None,
    combined: Optional[bool] = None,
    individual: Optional[bool] = None,
    format: Optional[str] = None,
    json_: Optional[bool] = Query(None, alias='json'),
):
    """
    Export contributions.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/export-summary',
    description=""" Provide a preflight summary of an export request. """,
    tags=['data_export_management', 'contribution_management'],
)
def post_export_summary(
    assignment: Optional[str] = None,
    country: Optional[str] = None,
    created_before: Optional[datetime] = Query(None, alias='createdBefore'),
    created_after: Optional[datetime] = Query(None, alias='createdAfter'),
    geohash: Optional[str] = None,
    has_location: Optional[bool] = Query(None, alias='hasLocation'),
    lat_long: Optional[str] = Query(None, alias='latLong'),
    radius: Optional[float] = None,
    media_type: Optional[str] = Query(None, alias='mediaType'),
    owned_by: Optional[str] = Query(None, alias='ownedBy'),
    q: Optional[str] = None,
    url_words: Optional[str] = Query(None, alias='urlWords'),
    user: Optional[str] = None,
):
    """
    Export contributions preflight summary.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/exports/{id}', tags=['data_export_management'])
def get_exports__id(id: str):
    """
    Get a single export job; poll to follow export progress.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/form-responses', tags=['form_management', 'contribution_management'])
def get_form_responses(
    user: Optional[str] = None,
    form: Optional[str] = None,
    contribution: Optional[str] = None,
):
    """
    List form responses
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/form-responses', tags=['form_management', 'contribution_management'])
def post_form_responses(body: FormResponseSubmission):
    """
    Submit a response to a form
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/form-responses/{id}', tags=['form_management'])
def get_form_responses__id(id: str):
    """
    Get a single form response by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/forms', tags=['form_management'])
def get_forms(owned_by: str = Query(..., alias='ownedBy')):
    """
    List forms
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/forms', tags=['form_management'])
def post_forms(body: FormSubmission):
    """
    Create a form
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/forms/{id}', tags=['form_management', 'contribution_management'])
def delete_forms__id(id: str):
    """
    Delete this form and all of it's responses.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/forms/{id}', tags=['form_management'])
def get_forms__id(id: str):
    """
    Get a single form by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/media',
    tags=['media_file_management', 'contribution_management'],
    security=[
        OAuth2PasswordBearer(
            name="None",
            token_url="https://api.contribly.com/1/https://api.contriby.com/1/token",
        ),
    ],
)
def post_media(body: str):
    """
    Submit a new media file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/notifications/contributions/{id}/preview',
    tags=['contribution_management', 'contribution_notification_management'],
)
def get_notifications_contributions__id_preview(id: str, message: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scopes',
    description=""" List available token scopes """,
    tags=[
        'assignment_management',
        'contribution_management',
        'form_management',
        'data_export_management',
        'media_file_management',
        'user_authentication_credentials',
        'change_log_retrieval',
        'contribution_notification_management',
        'artifact_format_management',
        'subscription_service_management',
        'tagging_system_management',
        'user_profile_management',
        'token_validation',
    ],
)
def get_scopes():
    """
    Scopes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscription-types',
    description=""" List available subscription types """,
    tags=['subscription_service_management'],
)
def get_subscription_types():
    """
    Subscription types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscriptions',
    tags=['subscription_service_management', 'user_authentication_credentials'],
)
def get_subscriptions(body: SubscriptionSubmission):
    """
    List subscriptions for the authorised user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/subscriptions/{id}', tags=['subscription_service_management'])
def delete_subscriptions__id(id: str):
    """
    Delete a subscription.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags', description=""" Retrieve tags. """, tags=['tagging_system_management']
)
def get_tags(
    owned_by: Optional[str] = Query(None, alias='ownedBy'),
    tag_set: Optional[str] = Query(None, alias='tagSet'),
    url_words: Optional[str] = Query(None, alias='urlWords'),
):
    """
    List tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/tags', tags=['tagging_system_management'])
def post_tags(body: TagSubmission):
    """
    Create a new tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/tags/{id}', tags=['tagging_system_management'])
def get_tags__id(id: str):
    """
    Retrieve a single tag by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tagsets',
    description=""" Retrieve tag sets. """,
    tags=['tagging_system_management'],
)
def get_tagsets(
    owned_by: Optional[str] = Query(None, alias='ownedBy'),
    url_words: Optional[str] = Query(None, alias='urlWords'),
):
    """
    List tag sets
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/tagsets', tags=['tagging_system_management'])
def post_tagsets(body: TagSetSubmission):
    """
    Create a new tag set
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/tagsets/{id}', tags=['tagging_system_management'])
def get_tagsets__id(id: str):
    """
    Retrieve a single tag set by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/users', tags=['user_profile_management'])
def get_users(
    assignment: Optional[str] = None,
    country: Optional[str] = None,
    minimum_contributions: Optional[float] = Query(None, alias='minimumContributions'),
    linked_profile: Optional[str] = Query(None, alias='linkedProfile'),
    owned_by: Optional[str] = Query(None, alias='ownedBy'),
    submitted_before: Optional[datetime] = Query(None, alias='submittedBefore'),
    submitted_after: Optional[datetime] = Query(None, alias='submittedAfter'),
    username: Optional[str] = None,
):
    """
    List users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/users/{id}', tags=['user_profile_management'])
def get_users__id(id: str):
    """
    Retrieve a single user by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/users/{id}/linked/{type}', tags=['user_profile_management'])
def get_users__id_linked__type(id: str, type: str = ...):
    """
    Retrieve a users linked profile by type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/verify',
    tags=['user_authentication_credentials', 'token_validation'],
    security=[
        OAuth2PasswordBearer(
            name="None",
            token_url="https://api.contribly.com/1/https://api.contriby.com/1/token",
        ),
    ],
)
def post_verify():
    """
    Verify token and return details of the owning user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
